// const { parseString } = require('xml2js')
const { Base64 } = require('js-base64')
const parser = require('fast-xml-parser')

function parsePath(key,pic){
  if(pic.indexOf('/')===0){
      return pic
  }else{
      let idx = key.lastIndexOf('/')
      if(idx===-1){
          return pic
      }else{
          return key.slice(0,idx+1)+pic
      }
  }
}

const ActionType = {
  DetectLabel:'DetectLabel',
  DetectType:'DetectType',
  WaterMark:'WaterMark',
  ImageProcess:'ImageProcess'
}

async function callFunction(tcb,options){
  let ciRes
  try{
    ciRes = await tcb.callFunction(options)
  }catch(err){
    throw new Error(`[@cloudbase/extension-ci] 调用扩展函数失败 ;  ${err.code} ${err.message}`)
  }
  if(ciRes.code){
    throw new Error(`[@cloudbase/extension-ci] 调用扩展函数失败 ; requestId : ${ciRes.requestId} ; ${ciRes.code} ; ${ciRes.message}`)
  }
  const { code } = ciRes.result || {}
  if(code){
    throw new Error(`[@cloudbase/extension-ci] ${code} ; requestId : ${ciRes.requestId} ;`)
  }
  return ciRes.result
}

async function invoke(opts, tcb){
    
    let {cloudPath,fileContent,action,operations} = opts
    if(!action || !ActionType[action]){
      throw new Error('[@cloudbase/extension-ci] action必须为正确的值')
    }

    cloudPath = cloudPath.indexOf('/')===0 ? cloudPath.slice(1) : cloudPath

    let headers = {}
    


    let method
    if(fileContent){
      if(!(fileContent instanceof Uint8Array)){
        throw new Error('[@cloudbase/extension-ci] fileContent一定要是Uint8Array对象')
      }
    }

    let query
    if(action === ActionType.DetectLabel){
      method = 'GET'
      query = {
        'ci-process':'detect-label'
      }
    } else if (action === ActionType.DetectType){
      method = 'GET'
      if(!operations.type){
        throw new Error('[@cloudbase/extension-ci] DetectType是，type字段不为空')
      }
      query = {
        'ci-process':'sensitive-content-recognition',
        'detect-type':operations.type
      }
      delete operations.type
    } else if(action === ActionType.ImageProcess){
      query = 'image_process'
      method = 'POST'
    } else if (action === ActionType.WaterMark){
      method = fileContent ? 'PUT' : 'POST'
      if(method==='POST'){
        query = 'image_process'
      }
      operations.rules.some(rule=>{
        if(typeof rule !== 'object'){
          throw new Error('[@cloudbase/extension-ci] WaterMark,rule必须为对象')
        }
      })
      // let waterMarkImages = operations.rules.map(processRule=>{
      //   let rule = processRule.rule
      //   if((rule.type===1 || rule.type === 2) && rule.image){
      //     if(rule.image.indexOf('/')===0){
      //       rule.image = rule.image.slice(1)
      //     }
      //     return rule.image
      //   }
      //   return null
      // }).filter(image=>!!image)

      for(let processRule of operations.rules){
        let rule = processRule.rule
        if( (rule.type === 1 || rule.type === 2) && rule.image){
          if(rule.image.indexOf('/')===0){
            rule.image = rule.image.slice(1)
          }
          processRule.rule = `watermark/${rule.mode}/type/${rule.type}/image/${rule.image}`
        }else if(rule.type=== 3 && rule.text){
          processRule.rule = `watermark/${rule.mode}/type/${rule.type}/text/${Base64.encode(rule.text).replace(/\//g,'_').replace(/=/g,'').replace(/\+/g,'-')}`
        }else{
          throw new Error('[@cloudbase/extension-ci] WaterMark,rule参数错误')
        }
      }
    }

    if(operations){
      headers['Pic-Operations'] = JSON.stringify(operations)
    }

    let functionOpts = {
      name:'tcb_extension_ci',
      data:{
        key: cloudPath,
        action,
        query : typeof query === 'object' ? query : null,
        headers,
        method
      }
    }

    let ciRes = await callFunction(tcb, functionOpts)

    const {  authorization, token, url, headers:headerRes } = ciRes || {}

    let options
    if(method === 'PUT'){
      const metaDataRes = await tcb.getUploadMetadata({cloudPath})
      const { data: { cosFileId } } = metaDataRes
      options = {
          url,
          headers:Object.assign({},headerRes,{
            'x-cos-security-token': token,
            'x-cos-meta-fileid': cosFileId,
            Authorization:authorization
          }),
          method,
          body:fileContent
      }
    } else {

        let cosFileId
        if(method === 'POST'){
          let fileIds = operations.rules.map(rule=>rule.fileid).filter(fileid=>!!fileid)
          if(fileIds && fileIds.length>0){
            let filePath = parsePath(cloudPath,fileIds[0])
            filePath = filePath.indexOf('/')===0 ? filePath.slice(1) : filePath
            const metaDataRes = await tcb.getUploadMetadata({cloudPath:filePath})
            cosFileId = metaDataRes.data.cosFileId
          }
        }

        let newUrl
        let queryStr
        if(query && typeof query === 'object'){
            queryStr = Object.keys(query).map(key=> key+'='+query[key]).join('&')
        }else if(query && typeof query === 'string'){
            queryStr = query
        }

        newUrl = url

        if(url.indexOf('?')>-1){
            newUrl += '&'+queryStr
        }else{
            newUrl += '?'+queryStr
        }

        options = {
            url:newUrl,
            headers:Object.assign({},headerRes,{
              Authorization:authorization,
              'x-cos-security-token': token,
            }),
            method:method.toUpperCase(),
        }
        if(method==='POST' && cosFileId){
          options.headers['x-cos-meta-fileid'] = cosFileId
        }
    }

    let body = await tcb.requestClient[method.toLowerCase()](options)
    if(body && body.data){
      let parseRes = parser.parse(body.data)
      if(parseRes && parseRes.UploadResult && parseRes.UploadResult.OriginalInfo && parseRes.UploadResult.OriginalInfo.Location){
        parseRes.UploadResult.OriginalInfo.Location = parseRes.UploadResult.OriginalInfo.Location.replace(/cos\.ap\-([a-z]+)\.myqcloud\.com/,'tcb.qcloud.la')
      }
      if(parseRes && parseRes.UploadResult && parseRes.UploadResult.ProcessResults &&
        parseRes.UploadResult.ProcessResults.Object && parseRes.UploadResult.ProcessResults.Object.Location
      ){
        parseRes.UploadResult.ProcessResults.Object.Location = parseRes.UploadResult.ProcessResults.Object.Location.replace(/cos\.ap\-([a-z]+)\.myqcloud\.com/,'tcb.qcloud.la')
      }
      body.data = parseRes
    }

    return body
}

module.exports = {
    name:'CloudInfinite',
    invoke
}